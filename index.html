<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>AR 靈異畫像 (動態生成版)</title>
    
    <!-- 核心引擎 -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column;
            justify-content: flex-end; align-items: center;
            padding-bottom: 40px;
        }

        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 140%);
            z-index: 1;
        }

        .scanline {
            width: 100%; height: 100px; z-index: 2;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 0, 0, 0.1) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute; bottom: 100%;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100%; }
        }
    </style>
</head>
<body style="margin: 0px; overflow: hidden;">

    <div class="vignette"></div>
    <div class="scanline"></div>
    
    <!-- UI 介面層 -->
    <div id="ui-layer">
        <div id="status-box" class="bg-black/70 border-l-4 border-yellow-500 px-6 py-3 text-gray-200 font-mono text-center transition-all duration-300">
            <h2 id="ui-title" class="text-xl font-bold text-yellow-500">初始化中...</h2>
            <p id="ui-desc" class="text-sm mt-1">正在載入設定檔與 AR 引擎</p>
        </div>
    </div>

    <!-- AR 場景：注意這裡先不放 Marker，由 JS 根據 config.json 動態插入 -->
    <a-scene id="main-scene" embedded arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;">
        
        <a-assets>
            <img id="ghost-asset" src="" crossorigin="anonymous">
        </a-assets>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
        let GAME_CONFIG = null;
        let isHaunted = false;
        let glitchInterval;

        // DOM 元素選取
        const scene = document.querySelector('#main-scene');
        const ghostAsset = document.querySelector('#ghost-asset');
        const uiTitle = document.querySelector('#ui-title');
        const uiDesc = document.querySelector('#ui-desc');
        const statusBox = document.querySelector('#status-box');

        // 1. 程式進入點：讀取 config.json
        window.addEventListener('load', () => {
            fetch('config.json')
                .then(response => {
                    if (!response.ok) throw new Error("無法讀取設定檔 (HTTP Error)");
                    return response.json();
                })
                .then(config => {
                    console.log("設定檔載入成功:", config);
                    GAME_CONFIG = config;
                    initAR(config);
                })
                .catch(err => {
                    console.error("設定檔讀取失敗:", err);
                    uiTitle.innerText = "系統錯誤";
                    uiDesc.innerHTML = "無法讀取 config.json<br>請確認是否使用 Server 開啟 (勿直接點兩下)";
                    statusBox.classList.replace('border-yellow-500', 'border-red-600');
                    document.querySelector('h2').classList.replace('text-yellow-500', 'text-red-500');
                });
        });

        // 2. 根據設定檔動態建立 AR 物件
        function initAR(config) {
            // 設定圖片資源
            ghostAsset.setAttribute('src', config.assets.ghostImage);
            
            // 建立 Marker 元素
            const marker = document.createElement('a-marker');
            marker.setAttribute('id', 'ghost-marker');
            
            // 判斷識別圖類型 (Hiro 或 自訂)
            // 如果 config 裡面指定了 pattern 並且有檔案路徑，就使用自訂圖
            if (config.assets.markerPreset === 'pattern' && config.assets.markerPatternUrl) {
                console.log("模式: 自訂識別圖", config.assets.markerPatternUrl);
                marker.setAttribute('type', 'pattern');
                marker.setAttribute('preset', 'pattern'); 
                marker.setAttribute('url', config.assets.markerPatternUrl);
            } else {
                console.log("模式: 預設 Hiro");
                marker.setAttribute('preset', 'hiro');
            }

            // 建立靈異內容 (內部結構)
            // 這裡會讀取 config.display 的長寬設定
            marker.innerHTML = `
                <a-image 
                    id="overlay-image"
                    src="#ghost-asset" 
                    rotation="-90 0 0" 
                    width="${config.display.width}" 
                    height="${config.display.height}"
                    opacity="0" 
                    position="0 0.1 0">
                </a-image>
                <a-plane 
                    id="blood-plane"
                    rotation="-90 0 0" 
                    width="${parseFloat(config.display.width) + 0.5}" 
                    height="${parseFloat(config.display.height) + 0.5}" 
                    color="${config.display.bloodColor}" 
                    opacity="0">
                </a-plane>
            `;

            // 將製作好的 Marker 加入場景
            scene.appendChild(marker);

            // 更新 UI 顯示為就緒狀態
            uiTitle.innerText = config.ui.title;
            uiTitle.className = "text-xl font-bold text-red-500";
            statusBox.className = "bg-black/70 border-l-4 border-red-600 px-6 py-3 text-gray-200 font-mono text-center";
            uiDesc.innerHTML = config.ui.scanningText;

            // 綁定事件監聽器
            setupEventListeners(marker);
        }

        // 3. 事件綁定：處理偵測到/遺失
        function setupEventListeners(marker) {
            const overlayImage = marker.querySelector('#overlay-image');
            const bloodPlane = marker.querySelector('#blood-plane');

            marker.addEventListener('markerFound', () => {
                if(!GAME_CONFIG) return;
                uiDesc.innerHTML = GAME_CONFIG.ui.foundText;
                uiDesc.classList.add('text-red-400', 'font-bold');
                startHaunting(overlayImage, bloodPlane);
            });

            marker.addEventListener('markerLost', () => {
                if(!GAME_CONFIG) return;
                uiDesc.innerHTML = GAME_CONFIG.ui.lostText;
                uiDesc.classList.remove('text-red-400', 'font-bold');
                stopHaunting(overlayImage, bloodPlane);
            });
        }

        // 4. 靈異特效邏輯
        function startHaunting(overlayImage, bloodPlane) {
            if (isHaunted) return;
            isHaunted = true;
            const effects = GAME_CONFIG.effects;

            // 淡入動畫
            let opacity = 0;
            const fadeIn = setInterval(() => {
                opacity += effects.fadeInSpeed;
                if (opacity >= effects.maxOpacity) clearInterval(fadeIn);
                overlayImage.setAttribute('opacity', opacity);
            }, 100);

            // 故障與閃爍循環
            glitchInterval = setInterval(() => {
                // 根據設定的機率發生故障
                if (Math.random() > (1 - effects.glitchFrequency)) {
                    // 隨機位移
                    const jitterX = (Math.random() - 0.5) * effects.jitterAmount;
                    const jitterZ = (Math.random() - 0.5) * effects.jitterAmount;
                    overlayImage.setAttribute('position', `${jitterX} 0.15 ${jitterZ}`);
                    
                    // 隨機變色
                    const randomColor = Math.random() > 0.5 ? '#ffaaaa' : '#ffffff';
                    overlayImage.setAttribute('color', randomColor);
                    
                    // 血光閃爍
                    bloodPlane.setAttribute('opacity', Math.random() * effects.bloodIntensity);
                } else {
                    // 恢復穩定
                    overlayImage.setAttribute('position', '0 0.1 0');
                    overlayImage.setAttribute('color', '#ffffff');
                    bloodPlane.setAttribute('opacity', 0);
                }
            }, 100);
        }

        // 5. 停止特效
        function stopHaunting(overlayImage, bloodPlane) {
            isHaunted = false;
            clearInterval(glitchInterval);
            // 重置所有屬性
            overlayImage.setAttribute('opacity', 0);
            overlayImage.setAttribute('position', '0 0.1 0');
            overlayImage.setAttribute('color', '#ffffff');
            bloodPlane.setAttribute('opacity', 0);
        }
    </script>
</body>
</html>
